# Convert the parse tree generated by the Wisent Parser into our AST.

from __future__ import print_function
from __future__ import unicode_literals
from __future__ import absolute_import

from ftl.parser import *
from ftl.ast import *


def print_parse_tree(tree, terminals, indent=0):
    """Print a parse tree to stdout."""
    prefix = "    "*indent
    # tree[0] is node type
    if tree[0] in terminals:
        # terminal, the rest is attribs from the scan
        print( prefix + repr(tree))
    else:
        # non-terminal, the rest is children
        print( prefix + str(tree[0]))
        for x in tree[1:]:
            print_parse_tree(x, terminals, indent+1)


class Parse2AST(object):
    """ Convert parse tree to a proper AST tree """
    terminals_name = { '.' : 'dot' }
    
    def __init__(self, terminals):
        self.terminals = terminals
    
    def run_on(self, ptree):
        #root = NPipeline()
        return self.do_trav(ptree)
        #return root
    
    def do_trav(self, ptree):
        """ Calls the appropriate parse method, uses reflection """
        # remove special symbols/rename
        n = ptree[0]
        if n in self.terminals_name:
            n = self.terminals_name[n]
        # get the method and call it
        if not hasattr(self, 'trav_{0}'.format(n)):
            assert False, "Parse2AST: missing method trav_{0} to traverse {1} at {2}".format(n, ptree[0], ptree[1])
        tr = getattr(self, 'trav_{0}'.format(n))
        return tr(ptree)
    
    
    def trav_start(self, ptree):
        nd = NModule()
        for k in ptree[1:]:
            n = self.do_trav(k)
            assert isinstance(n, NDef)
            nd.add_def(n)
        return nd
    
    
    def trav_def_stmt(self, ptree):
        # trav def prototype
        nd = self.do_trav(ptree[1])
        if ptree[2][0] == 'is':
            nd.set_body( self.do_trav(ptree[3]) )
        return nd
    
    
    def trav_def_prototype(self, ptree):
        nd = NDef(self.do_trav(ptree[2]) )
        for i in ptree[3:]:
            k = self.do_trav(i)
            if isinstance(k, list):
                nd.set_params(k)
                continue
            if isinstance(k, NTypeSpec):
                nd.set_rtype(k)
                continue
            if isinstance(k, NValueExpr):
                nd.set_when(k)
                continue
            assert False, "Unknown node: {0} -> {1}".format(i[0], k.__class__.__name__)
        return nd
    
    
    def trav_param_list(self, ptree):
        nd = []
        for i in ptree[1:]:
            if i[0] in ['(', ',', ')']:
                continue
            k = self.do_trav(i)
            #assert isinstance(k, NParam)
            nd.append(k)
        return nd
    
    
    def trav_param(self, ptree):
        nd = NParam( self.do_trav(ptree[1]) )
        for i in ptree[2:]:
            if i[0] in [':=']:
                continue
            
            k = self.do_trav(i)
            if isinstance(k, NTypeSpec):
                nd.set_rtype(k)
                continue
            if isinstance(k, NValueExpr):
                nd.set_default(k)
                continue
            assert False
        return nd
    
    
    def trav_pipeline(self, ptree):
        nd = NPipeline()
        for k in ptree[1:]:
            pi = self.do_trav(k)
            assert pi is not None, 'at {0}'.format(str(k))
            nd.add_flowitem(pi)
        return nd
    
    
    def trav_cluster(self, ptree):
        nd = NCluster()
        ik = 1
        #print ptree[ik][0]
        if ptree[ik][0] == 'ID':
            nd.set_name(ptree[ik][2])
            assert ptree[ik+1][0] == ':'
            ik += 2
            
        assert ptree[ik][0] == '{'
        nd.set_loc(ptree[ik][1])
        
        for k in ptree[ik+1:]:
            if k[0] in ('|', '}', ':'):
                continue
            nk = self.do_trav(k)
            if isinstance(nk, NValueExpr):
                # 'when' condition
                wp = NFlowPrf('WHEN', [nk])
                nd.add_ppline( wp )
            else:
                nd.add_ppline( nk )
        
        return nd


    def trav_piperef(self, ptree):
        nd = NTubeLink()
        nd.set_loc(ptree[1][1])
        
        for k in ptree[1:]:
            if k[0] in ('=>'):
                nd.set_implicit_in(True)
                nd.set_implicit_out(True)
                continue
            if k[0] in ('=<'): 
                nd.set_implicit_in(True)
                continue
            if k[0] in ('>='): 
                nd.set_implicit_out(True)
                continue
            nk = self.do_trav(k)
            if isinstance(nk, NTypeSpec):
                nd.set_rtype(nk)
                continue
            if isinstance(nk, NId):
                nd.set_name(nk)
                continue
            assert False
        return nd


    def trav_component(self, ptree):
        qid1 = self.do_trav( ptree[1] )
        assert isinstance(qid1, NQualId)
        # qid1 is either a name, or ref to def
        qid2 = None
        tp = None
        args = []
        
        for k in ptree[2:]:
            nk = self.do_trav(k)
            if isinstance(nk, NQualId):
                qid2 = nk
                continue
            if isinstance(nk, NTypeSpec):
                tp = nk
                continue
            if isinstance(nk, list):
                args = nk
                continue
            assert False
        
        if qid2 is None:
            fun = qid1
            name = None
        else:
            fun = qid2
            name = qid1
            #assert name.
        
        nd = NFlowAp(fun, args)
        nd.set_loc( ptree[1][1] )
        return nd
    
    
    def trav_value_expr(self, ptree):
        return self.do_trav( ptree[2] )
    
    
    def trav_expr(self, ptree):
        return self.do_trav( ptree[1] )
    
    
    def trav_qual_id(self, ptree):
        nd = NQualId([])
        for k in ptree[1:]:
            if k in ['.']:
                continue
            nk = self.do_trav(k)
            nd.add_id(nk)
        return nd
    
    
    def trav_when_cond(self, ptree):
        return self.do_trav(ptree[2]); 
    
    
    def trav_ap_fun(self, ptree):
        fun = self.do_trav(ptree[1])
        args = self.do_trav(ptree[2])
        nd = NAp(fun, args)
        nd.set_loc(ptree[1][1])
        return nd
    
    
    def trav_arg_list(self, ptree):
        return self.do_trav(ptree[2])
    
    
    def trav_expr_list(self, ptree):
        nd = []
        for k in ptree[1:]:
            if k[0]==',':
                continue
            nd.append( self.do_trav(k) )
        return nd
    
    def trav_addition(self, ptree):
        return NPrf(NPrf.ADD, [self.do_trav(ptree[1]), self.do_trav(ptree[3])], loc=ptree[2][1])
    
    def trav_product(self, ptree):
        return NPrf(NPrf.MUL, [self.do_trav(ptree[1]), self.do_trav(ptree[3])], loc=ptree[2][1])
    
    def trav_ID(self, ptree):
        return NId(ptree[2], loc=ptree[1])
    
    def trav_NUMBER(self, ptree):
        return NConst(ptree[2], loc=ptree[1])
    
    def trav_update(self, ptree):
        nd = NUpdate(self.do_trav(ptree[2]), loc=ptree[1][1])
        return nd
    
    def trav_dot(self, ptree):
        return NPrf(NPrf.DOT, [], loc=ptree[1])
    
    def trav_defattr(self, ptree):
        nd = NDefAttr(ptree[2][2], loc=ptree[1][1])
        tp = self.do_trav(ptree[3])
        act = self.do_trav(ptree[4])
        nd.set_rtype(tp)
        nd.set_action(act)
        return nd
    
    
    def trav_let_stmt(self, ptree):
        nd = NFlowPrf(NFlowPrf.LET, [self.do_trav(ptree[2])])
        if len(ptree) > 3:
            nd.set_rtype( self.do_trav(ptree[3]) )
        return nd
    
    
    def trav_typespec(self, ptree):
        # FIXME: typesystem??
        return NTypeSpec()
    
    
    
    
    